var Y=Object.defineProperty;var te=(c,e,t)=>e in c?Y(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var o=(c,e)=>Y(c,"name",{value:e,configurable:!0});var i=(c,e,t)=>(te(c,typeof e!="symbol"?e+"":e,t),t);import Q from"webpack";import se from"lodash";var{compact:ie,uniq:re}=se,R=class R{constructor(e,t,s){i(this,"assetManager");i(this,"moduleDirectoryLocator");i(this,"licenseMetaAggregator");this.assetManager=e,this.moduleDirectoryLocator=t,this.licenseMetaAggregator=s}async writeLicenseFiles(e,t){let s=this.getModuleDirs(e),r=await t.includePackages(),n=await this.licenseMetaAggregator.aggregateMeta([...new Set([...s,...r])]),a=JSON.stringify(n,null,2);this.assetManager.addFile(t.outputFilename,a);for(let l of Object.keys(t.additionalFiles)){let d=await t.additionalFiles[l](n);this.assetManager.addFile(l,d)}}getModuleDirs(e){return re(ie(e.map(t=>this.moduleDirectoryLocator.getModuleDir(t))))}};o(R,"LicenseFileWriter");var u=R;import ne from"spdx-expression-validate";var P=class P{constructor(e,t=[]){i(this,"alertAggregator");i(this,"preferredLicenses");this.alertAggregator=e,this.preferredLicenses=t}identifyLicense(e,t){let s=`${e.name}@${e.version}`,r;return t.licenseOverrides[s]?r=t.licenseOverrides[s]:typeof e.license=="object"?r=e.license.type:e.license?r=e.license:Array.isArray(e.licenses)&&e.licenses.length>0?r=this.findPreferredLicense(e.licenses.map(n=>n.type))||e.licenses[0].type:typeof e.licenses=="string"&&(r=e.licenses),r?t.unacceptableLicenseTest(r)?this.alertAggregator.addError(`Found unacceptable license "${r}" for ${s}`):ne(r)||this.alertAggregator.addError(`License "${r}" for ${s} is not a valid SPDX expression!`):this.alertAggregator.addError(`Could not find license info for ${s}`),r||null}findPreferredLicense(e){for(let t of this.preferredLicenses)for(let s of e)if(t===s)return t;return null}};o(P,"LicenseIdentifier");var p=P;import{join as ce}from"path";import oe from"needle";async function ae(c){let e=await oe("get",c);return e.statusCode===200?e.body:null}o(ae,"fetch");var le="https://raw.githubusercontent.com/spdx/license-list-data",M=class M{constructor(e=ae){i(this,"request");i(this,"cache");this.request=e,this.cache={}}async retrieveLicenseText(e){if(!this.cache[e]){let t=await this.request(`${le}/master/text/${e}.txt`);this.cache[e]=t}return this.cache[e]||null}};o(M,"DefaultLicenseTextProvider");var g=M;var I=class I{constructor(e,t,s,r=new g){i(this,"alertAggregator");i(this,"fileSystem");i(this,"options");i(this,"defaultLicenseReader");this.alertAggregator=e,this.fileSystem=t,this.options=s,this.defaultLicenseReader=r}async readLicenseText(e,t,s){let r=`${e.name}@${e.version}`;if(!t)return null;if(t.indexOf("SEE LICENSE IN ")===0){let l=t.split(" ")[3];try{return this.readFile(s,l)}catch{this.alertAggregator.addError(`could not find file specified in package.json license field of ${r}`)}}let n=this.fileSystem.listPaths(s),a=this.getLicenseFilename(n);return a!==null?this.readFile(s,a):this.options.replenishDefaultLicenseTexts?await this.getDefaultLicenseText(t):null}getLicenseFilename(e){for(let t of e)if(/^licen[cs]e/i.test(t))return t;return null}readFile(e,t){return this.fileSystem.readFile(ce(e,t)).replace(/\r\n/g,`
`)}async getDefaultLicenseText(e){return await this.defaultLicenseReader.retrieveLicenseText(e)}};o(I,"LicenseTextReader");var m=I;import{join as de}from"path";var O=class O{constructor(e){i(this,"fileSystem");this.fileSystem=e}async readNoticeText(e){let t=this.fileSystem.listPaths(e).find(r=>/^notice/i.test(r));if(!t)return null;let s=de(e,t);return this.fileSystem.readFile(s).replace(/\r\n/g,`
`)}};o(O,"NoticeTextReader");var y=O;var J=class J{constructor(e,t,s,r,n=new p(t),a=new m(t,e,s),l=new y(e)){i(this,"options");i(this,"packageJsonReader");i(this,"licenseIdentifier");i(this,"licenseTextReader");i(this,"noticeTextReader");this.options=s,this.packageJsonReader=r,this.licenseIdentifier=n,this.licenseTextReader=a,this.noticeTextReader=l}getNpmTarballUrl(e,t){let s=e[0]!=="@"?e:e.split("/")[1],r=t.indexOf("+"),n=r===-1?t:t.substring(0,r);return`https://registry.npmjs.org/${e}/-/${s}-${n}.tgz`}async aggregateMeta(e){let t=new Set,s=[],r=e.sort((n,a)=>this.packageJsonReader.readPackageJson(n).name.localeCompare(this.packageJsonReader.readPackageJson(a).name));for(let n of r){let a=this.packageJsonReader.readPackageJson(n),l=`${a.name}@${a.version}`;if(t.has(l)||this.options.excludedPackageTest(a.name,a.version))continue;t.add(l);let d=this.licenseIdentifier.identifyLicense(a,this.options),f=await this.licenseTextReader.readLicenseText(a,d,n),h=this.options.includeNoticeText?await this.noticeTextReader.readNoticeText(n):void 0;s.push({name:a.name,version:a.version,author:this.getAuthor(a),repository:this.getRepository(a),source:this.getNpmTarballUrl(a.name,a.version),license:d,licenseText:f,...h?{noticeText:h}:{}})}return s}getAuthor(e){return typeof e.author=="object"?`${e.author.name}${e.author.email?` <${e.author.email}>`:""}${e.author.url?` (${e.author.url})`:""}`:e.author}getRepository(e){return e.repository&&e.repository.url?e.repository.url:typeof e.repository=="string"?e.repository:null}};o(J,"LicenseMetaAggregator");var w=J;import{resolve as fe,sep as T}from"path";var j=class j{constructor(e,t,s){i(this,"fileSystem");i(this,"buildRoot");i(this,"packageJsonReader");this.fileSystem=e,this.buildRoot=t,this.packageJsonReader=s}getModuleDir(e){let t=e.substring(0,e.lastIndexOf(T));return this.checkModuleDir(t)}checkModuleDir(e){let t=null,s=null,r=null;do{if(this.fileSystem.pathExists(`${e}${T}package.json`)){let n=this.packageJsonReader.readPackageJson(e);n.name!==void 0&&n.version!==void 0&&(t=e,(n.license!==void 0||n.licenses!==void 0)&&(s=e))}r=e,e=fe(`${e}${T}..${T}`)}while(!s&&e!==r&&e!==this.buildRoot);return s||t}};o(j,"ModuleDirectoryLocator");var x=j;import ue from"spdx-expression-validate";var he={additionalFiles:{},licenseOverrides:{},outputFilename:"oss-licenses.json",replenishDefaultLicenseTexts:!1,includeNoticeText:!1,unacceptableLicenseTest:()=>!1,excludedPackageTest:()=>!1,includePackages:()=>[]},B=he;var N=class N{constructor(e){i(this,"alertAggregator");this.alertAggregator=e}getOptions(e){return this.validateOptions(e),{...B,...e}}validateOptions(e){if(e.additionalFiles)for(let t of Object.keys(e.additionalFiles))typeof e.additionalFiles[t]!="function"&&this.alertAggregator.addError(`Invalid additionalFiles option: Value for key "${t}" is not a function!`);if(e.licenseOverrides)for(let t of Object.keys(e.licenseOverrides))ue(e.licenseOverrides[t])||this.alertAggregator.addError(`Invalid licenseOverrides option: "${e.licenseOverrides[t]}" is not a valid SPDX expression!`);e.replenishDefaultLicenseTexts&&typeof e.replenishDefaultLicenseTexts!="boolean"&&this.alertAggregator.addError("Invalid replenishDefaultLicenseTexts option: Not a boolean!"),e.includePackages&&typeof e.includePackages!="function"&&this.alertAggregator.addError("Invalid includePackages option: Not a function!")}};o(N,"OptionsProvider");var k=N;import{join as pe}from"path";var z=class z{constructor(e){i(this,"fileSystem");i(this,"cache");this.fileSystem=e,this.cache={}}readPackageJson(e){if(!this.cache[e]){let t=pe(e,"package.json"),s=JSON.parse(this.fileSystem.readFile(t));this.cache[e]=s}return this.cache[e]}};o(z,"PackageJsonReader");var v=z;import ge from"webpack";var K=ge.WebpackError,D=class D{constructor(e){i(this,"compilation");i(this,"errors");i(this,"warnings");this.compilation=e,this.errors=[],this.warnings=[]}addError(e){this.errors.push(e)}addWarning(e){this.warnings.push(e)}flushAlerts(e){this.compilation.errors.push(...this.errors.map(t=>new K(`${e}: ${t}`))),this.errors=[],this.compilation.warnings.push(...this.warnings.map(t=>new K(`${e}: ${t}`))),this.warnings=[]}};o(D,"WebpackAlertAggregator");var A=D;import me from"webpack";var ye=me.sources,G=class G{constructor(e){i(this,"compilation");this.compilation=e}addFile(e,t){this.compilation.assets[e]=new ye.RawSource(t)}};o(G,"WebpackAssetManager");var $=G;var W=class W{iterateModules(e,t,s){if(typeof e.chunkGraph<"u")for(let r of e.chunkGraph.getChunkModulesIterable(t))s(r);else if(typeof t.modulesIterable<"u")for(let r of t.modulesIterable)s(r);else typeof t.forEachModule=="function"?t.forEachModule(s):Array.isArray(t.modules)&&t.modules.forEach(r=>s(r));if(typeof e.chunkGraph<"u")for(let r of e.chunkGraph.getChunkEntryModulesIterable(t))s(r);else t.entryModule&&s(t.entryModule)}};o(W,"WebpackChunkModuleIterator");var F=W;var q=class q{iterateFiles({resource:e,rootModule:t,fileDependencies:s,dependencies:r},n){e?n(e):t?.resource&&n(t.resource),s&&s.forEach(a=>n(a)),r&&r.forEach(({originModule:a,_parentModule:l})=>{a?.resource&&n(a.resource),l?.resource&&n(l.resource)})}};o(q,"WebpackModuleFileIterator");var S=q;var U=class U{constructor(e=new F,t=new S){i(this,"moduleIterator");i(this,"fileIterator");this.moduleIterator=e,this.fileIterator=t}iterateChunks(e,t){let s=[];for(let r of t)this.moduleIterator.iterateModules(e,r,n=>{this.fileIterator.iterateFiles(n,a=>{s.push(a)})});return s}};o(U,"WebpackChunkIterator");var b=U;var X=class X{constructor(e){i(this,"fs");this.fs=e}pathExists(e){try{return this.fs.statSync(e),!0}catch{return!1}}readFile(e){return this.fs.readFileSync(e).toString("utf8")}listPaths(e){return this.fs.readdirSync(e)}};o(X,"WebpackFileSystem");var E=X;var we=Q.WebpackError,H="WebpackLicensePlugin",V=class V{constructor(e={}){i(this,"pluginOptions");i(this,"filenames");i(this,"createdFiles");i(this,"observedCompilers");this.pluginOptions=e,this.filenames=new Set,this.createdFiles=!1,this.observedCompilers=[]}apply(e){typeof e.hooks<"u"?(e.hooks.compilation.tap("webpack-license-plugin",this.handleCompilation.bind(this,e)),e.hooks.watchRun.tapAsync("webpack-license-plugin",this.handleWatchRun.bind(this))):typeof e.plugin<"u"&&(e.plugin("compilation",this.handleCompilation.bind(this,e)),e.plugin("watchRun",this.handleWatchRun.bind(this)))}async handleWatchRun(e,t){this.createdFiles=!1,this.observedCompilers=[],t()}handleCompilation(e,t){if(typeof t.hooks<"u")if(typeof t.hooks.processAssets<"u"){let s=this.handleChunkAssetOptimization.bind(this,e,t,t.chunks);t.hooks.processAssets.tapAsync({name:"webpack-license-plugin",stage:Q.Compilation.PROCESS_ASSETS_STAGE_ANALYSE},(r,n)=>s(n))}else t.hooks.optimizeChunkAssets.tapAsync("webpack-license-plugin",this.handleChunkAssetOptimization.bind(this,e,t));else typeof t.plugin<"u"&&t.plugin("optimize-chunk-assets",this.handleChunkAssetOptimization.bind(this,e,t))}async handleChunkAssetOptimization(e,t,s,r){if(this.observedCompilers.push({name:t.compiler.name,isChild:t.compiler.isChild()}),this.createdFiles){let C=this.observedCompilers.map(({name:_,isChild:ee})=>`compiler: ${_}, isChild: ${ee}`).join(`
`),Z=new we(`${H}: Found licenses after license files were already created.
If you see this message, you ran into an edge case we thought would not happen. Please open an isssue at https://github.com/codepunkt/webpack-license-plugin/issues with details of your webpack configuration so we can invastigate it further.
${C}`);t.errors.push(Z),r();return}t.compiler.isChild()||(this.createdFiles=!0);let n=new A(t),l=new k(n).getOptions(this.pluginOptions);n.flushAlerts(H);let d=new b;for(let C of d.iterateChunks(t,s))this.filenames.add(C);if(t.compiler.isChild()){r();return}let f=new E(e.inputFileSystem),h=new v(f);await new u(new $(t),new x(f,e.options.context,h),new w(f,n,l,h)).writeLicenseFiles([...this.filenames],l),n.flushAlerts(H),r()}};o(V,"WebpackLicensePlugin");var L=V;var Lt=L;export{Lt as default};
//# sourceMappingURL=index.js.map