{"version":3,"sources":["../src/index.ts","../src/WebpackLicensePlugin.ts","../src/LicenseFileWriter.ts","../src/LicenseIdentifier.ts","../src/LicenseTextReader.ts","../src/DefaultLicenseTextProvider.ts","../src/NoticeTextReader.ts","../src/LicenseMetaAggregator.ts","../src/ModuleDirectoryLocator.ts","../src/OptionsProvider.ts","../src/defaultOptions.ts","../src/PackageJsonReader.ts","../src/WebpackAlertAggregator.ts","../src/WebpackAssetManager.ts","../src/WebpackChunkModuleIterator.ts","../src/WebpackModuleFileIterator.ts","../src/WebpackChunkIterator.ts","../src/WebpackFileSystem.ts"],"names":["src_exports","__export","src_default","__toCommonJS","import_webpack","import_lodash","compact","uniq","lodash","LicenseFileWriter","constructor","assetManager","moduleDirectoryLocator","licenseMetaAggregator","writeLicenseFiles","filenames","options","moduleDirs","getModuleDirs","includePackages","licenseMeta","aggregateMeta","Set","fileContents","JSON","stringify","addFile","outputFilename","filename","Object","keys","additionalFiles","result","map","getModuleDir","_LicenseFileWriter","import_spdx_expression_validate","LicenseIdentifier","alertAggregator","preferredLicenses","identifyLicense","meta","id","name","version","license","licenseOverrides","type","Array","isArray","licenses","length","findPreferredLicense","l","unacceptableLicenseTest","addError","validate","licenseTypes","preferredLicenseType","licenseType","_LicenseIdentifier","import_node_path","import_needle","fetch","url","res","needle","statusCode","body","REPO_URL","DefaultLicenseTextProvider","request","cache","retrieveLicenseText","_DefaultLicenseTextProvider","LicenseTextReader","fileSystem","defaultLicenseReader","readLicenseText","moduleDir","indexOf","split","readFile","pathsInModuleDir","listPaths","licenseFilename","getLicenseFilename","replenishDefaultLicenseTexts","getDefaultLicenseText","paths","path","test","directory","join","replace","_LicenseTextReader","NoticeTextReader","readNoticeText","noticeFilename","find","noticeFilePath","_NoticeTextReader","LicenseMetaAggregator","packageJsonReader","licenseIdentifier","licenseTextReader","noticeTextReader","getNpmTarballUrl","pkgName","pkgVersion","scopelessName","plusPos","substring","packageSet","sortedModuleDirs","sort","a","b","readPackageJson","localeCompare","packageIdentifier","has","excludedPackageTest","add","licenseText","noticeText","includeNoticeText","undefined","push","author","getAuthor","repository","getRepository","source","email","_LicenseMetaAggregator","ModuleDirectoryLocator","buildRoot","lastIndexOf","sep","checkModuleDir","dirWithVersion","dirWithLicense","prevModuleDir","pathExists","packageMeta","resolve","_ModuleDirectoryLocator","defaultOptions","defaultOptions_default","OptionsProvider","getOptions","inputOptions","validateOptions","fileName","packageVersion","_OptionsProvider","PackageJsonReader","parse","_PackageJsonReader","WebpackError","webpack","WebpackAlertAggregator","compilation","errors","warnings","message","addWarning","flushAlerts","prefix","e","w","_WebpackAlertAggregator","sources","WebpackAssetManager","contents","assets","RawSource","_WebpackAssetManager","WebpackChunkModuleIterator","iterateModules","chunk","callback","chunkGraph","module","getChunkModulesIterable","modulesIterable","forEachModule","modules","forEach","getChunkEntryModulesIterable","entryModule","_WebpackChunkModuleIterator","WebpackModuleFileIterator","iterateFiles","resource","rootModule","fileDependencies","dependencies","dep","originModule","_parentModule","_WebpackModuleFileIterator","WebpackChunkIterator","moduleIterator","fileIterator","iterateChunks","chunks","_WebpackChunkIterator","WebpackFileSystem","fs","statSync","readFileSync","toString","dir","readdirSync","_WebpackFileSystem","pluginName","WebpackLicensePlugin","pluginOptions","createdFiles","observedCompilers","apply","compiler","hooks","tap","handleCompilation","bind","watchRun","tapAsync","handleWatchRun","plugin","_","processAssets","boundHandleChunkAssetOptimization","handleChunkAssetOptimization","stage","Compilation","PROCESS_ASSETS_STAGE_ANALYSE","optimizeChunkAssets","isChild","observedCompilersMessage","errorMessage","chunkIterator","inputFileSystem","context","_WebpackLicensePlugin"],"mappings":"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","sourcesContent":["import WebpackLicensePlugin from './WebpackLicensePlugin'\n\nexport default WebpackLicensePlugin\n","import type { Chunk, Compilation, Compiler } from 'webpack'\nimport webpack from 'webpack'\nimport LicenseFileWriter from './LicenseFileWriter'\nimport LicenseMetaAggregator from './LicenseMetaAggregator'\nimport ModuleDirectoryLocator from './ModuleDirectoryLocator'\nimport OptionsProvider from './OptionsProvider'\nimport PackageJsonReader from './PackageJsonReader'\nimport WebpackAlertAggregator from './WebpackAlertAggregator'\nimport WebpackAssetManager from './WebpackAssetManager'\nimport WebpackChunkIterator from './WebpackChunkIterator'\nimport WebpackFileSystem from './WebpackFileSystem'\nimport type IPluginOptions from './types/IPluginOptions'\nimport type IWebpackPlugin from './types/IWebpackPlugin'\n\nconst WebpackError = webpack.WebpackError\nconst pluginName = 'WebpackLicensePlugin'\n\ninterface ObservedCompiler {\n  name: string\n  isChild: boolean\n}\n\nexport default class WebpackLicensePlugin implements IWebpackPlugin {\n  private readonly filenames = new Set<string>()\n  private createdFiles = false\n  private observedCompilers: ObservedCompiler[] = []\n\n  constructor(private pluginOptions: Partial<IPluginOptions> = {}) {}\n\n  public apply(compiler: Compiler) {\n    if (typeof compiler.hooks !== 'undefined') {\n      compiler.hooks.compilation.tap(\n        'webpack-license-plugin',\n        this.handleCompilation.bind(this, compiler),\n      )\n      compiler.hooks.watchRun.tapAsync(\n        'webpack-license-plugin',\n        this.handleWatchRun.bind(this),\n      )\n    }\n    // @ts-expect-error plugin doesn't exist on compiler\n    else if (typeof compiler.plugin !== 'undefined') {\n      // @ts-expect-error plugin doesn't exist on compiler\n      compiler.plugin(\n        'compilation',\n        this.handleCompilation.bind(this, compiler),\n      )\n      // @ts-expect-error plugin doesn't exist on compiler\n      compiler.plugin('watchRun', this.handleWatchRun.bind(this))\n    }\n  }\n\n  public async handleWatchRun(_: unknown, callback: () => void) {\n    this.createdFiles = false\n    this.observedCompilers = []\n    callback()\n  }\n\n  public handleCompilation(compiler: Compiler, compilation: Compilation) {\n    if (typeof compilation.hooks !== 'undefined') {\n      if (typeof compilation.hooks.processAssets !== 'undefined') {\n        const boundHandleChunkAssetOptimization\n          = this.handleChunkAssetOptimization.bind(\n            this,\n            compiler,\n            compilation,\n            compilation.chunks,\n          )\n\n        compilation.hooks.processAssets.tapAsync(\n          {\n            name: 'webpack-license-plugin',\n            stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ANALYSE,\n          },\n          (assets, callback) => boundHandleChunkAssetOptimization(callback),\n        )\n      }\n      else {\n        compilation.hooks.optimizeChunkAssets.tapAsync(\n          'webpack-license-plugin',\n          this.handleChunkAssetOptimization.bind(this, compiler, compilation),\n        )\n      }\n    }\n    // @ts-expect-error plugin doesn't exist on compilation\n    else if (typeof compilation.plugin !== 'undefined') {\n      // @ts-expect-error plugin doesn't exist on compilation\n      compilation.plugin(\n        'optimize-chunk-assets',\n        this.handleChunkAssetOptimization.bind(this, compiler, compilation),\n      )\n    }\n  }\n\n  public async handleChunkAssetOptimization(\n    compiler: Compiler,\n    compilation: Compilation,\n    chunks: Set<Chunk>,\n    callback: () => void,\n  ) {\n    this.observedCompilers.push({\n      name: compilation.compiler.name,\n      isChild: compilation.compiler.isChild(),\n    })\n\n    if (this.createdFiles) {\n      const observedCompilersMessage = this.observedCompilers\n        .map(({ name, isChild }) => `compiler: ${name}, isChild: ${isChild}`)\n        .join('\\n')\n      const errorMessage = new WebpackError(\n        `${pluginName}: Found licenses after license files were already created.\\nIf you see this message, you ran into an edge case we thought would not happen. Please open an isssue at https://github.com/codepunkt/webpack-license-plugin/issues with details of your webpack configuration so we can invastigate it further.\\n${observedCompilersMessage}`,\n      )\n      compilation.errors.push(errorMessage)\n      callback()\n      return\n    }\n\n    if (!compilation.compiler.isChild()) {\n      this.createdFiles = true\n    }\n\n    const alertAggregator = new WebpackAlertAggregator(compilation)\n    const optionsProvider = new OptionsProvider(alertAggregator)\n\n    const options = optionsProvider.getOptions(this.pluginOptions)\n    alertAggregator.flushAlerts(pluginName)\n\n    const chunkIterator = new WebpackChunkIterator()\n    for (const filename of chunkIterator.iterateChunks(compilation, chunks)) {\n      this.filenames.add(filename)\n    }\n\n    if (compilation.compiler.isChild()) {\n      callback()\n      return\n    }\n\n    const fileSystem = new WebpackFileSystem(compiler.inputFileSystem)\n    const packageJsonReader = new PackageJsonReader(fileSystem)\n    const licenseFileWriter = new LicenseFileWriter(\n      new WebpackAssetManager(compilation),\n      new ModuleDirectoryLocator(\n        fileSystem,\n        compiler.options.context,\n        packageJsonReader,\n      ),\n      new LicenseMetaAggregator(\n        fileSystem,\n        alertAggregator,\n        options,\n        packageJsonReader,\n      ),\n    )\n\n    await licenseFileWriter.writeLicenseFiles([...this.filenames], options)\n    alertAggregator.flushAlerts(pluginName)\n\n    callback()\n  }\n}\n","import lodash from 'lodash'\nimport type IAssetManager from './types/IAssetManager'\nimport type ILicenseMetaAggregator from './types/ILicenseMetaAggregator'\nimport type IModuleDirectoryLocator from './types/IModuleDirectoryLocator'\nimport type IPluginOptions from './types/IPluginOptions'\n\nconst { compact, uniq } = lodash\n\nexport default class LicenseFileWriter {\n  constructor(\n    private assetManager: IAssetManager,\n    private moduleDirectoryLocator: IModuleDirectoryLocator,\n    private licenseMetaAggregator: ILicenseMetaAggregator,\n  ) {}\n\n  public async writeLicenseFiles(\n    filenames: string[],\n    options: IPluginOptions,\n  ): Promise<void> {\n    const moduleDirs = this.getModuleDirs(filenames)\n    const includePackages = await options.includePackages()\n    const licenseMeta = await this.licenseMetaAggregator.aggregateMeta([\n      ...new Set([...moduleDirs, ...includePackages]),\n    ])\n\n    const fileContents = JSON.stringify(licenseMeta, null, 2)\n    this.assetManager.addFile(options.outputFilename, fileContents)\n\n    for (const filename of Object.keys(options.additionalFiles)) {\n      const result = await options.additionalFiles[filename](licenseMeta)\n      this.assetManager.addFile(filename, result)\n    }\n  }\n\n  public getModuleDirs(filenames: string[]): string[] {\n    return uniq(\n      compact(\n        filenames.map((filename) => {\n          return this.moduleDirectoryLocator.getModuleDir(filename)\n        }),\n      ),\n    )\n  }\n}\n","import validate from 'spdx-expression-validate'\nimport type IAlertAggregator from './types/IAlertAggregator'\nimport type IPackageJson from './types/IPackageJson'\nimport type IPluginOptions from './types/IPluginOptions'\n\n/**\n * Identifies license type based on package.json and selects\n * preferred license type if multiple are found\n */\nexport default class LicenseIdentifier {\n  constructor(\n    private alertAggregator: IAlertAggregator,\n    private readonly preferredLicenses: string[] = [],\n  ) {}\n\n  public identifyLicense(\n    meta: IPackageJson,\n    options: Pick<\n      IPluginOptions,\n      'licenseOverrides' | 'unacceptableLicenseTest'\n    >,\n  ): string | null {\n    const id = `${meta.name}@${meta.version}`\n    let license: string\n\n    if (options.licenseOverrides[id]) {\n      license = options.licenseOverrides[id]\n    }\n    else if (typeof meta.license === 'object') {\n      license = meta.license.type\n    }\n    else if (meta.license) {\n      license = meta.license\n    }\n    else if (Array.isArray(meta.licenses) && meta.licenses.length > 0) {\n      // handle deprecated `licenses` field\n      license\n        = this.findPreferredLicense(meta.licenses.map(l => l.type))\n        || meta.licenses[0].type\n    }\n    else if (typeof meta.licenses === 'string') {\n      // handle invalid string values for deprecated `licenses` field\n      // unfortunately, these are rather common\n      license = meta.licenses\n    }\n\n    if (!license) {\n      this.alertAggregator.addError(`Could not find license info for ${id}`)\n    }\n    else if (options.unacceptableLicenseTest(license)) {\n      this.alertAggregator.addError(\n        `Found unacceptable license \"${license}\" for ${id}`,\n      )\n    }\n    else if (!validate(license)) {\n      this.alertAggregator.addError(\n        `License \"${license}\" for ${id} is not a valid SPDX expression!`,\n      )\n    }\n\n    return license || null\n  }\n\n  private findPreferredLicense(licenseTypes: string[]): string | null {\n    for (const preferredLicenseType of this.preferredLicenses) {\n      for (const licenseType of licenseTypes) {\n        if (preferredLicenseType === licenseType) {\n          return preferredLicenseType\n        }\n      }\n    }\n    return null\n  }\n}\n","import { join } from 'node:path'\nimport DefaultLicenseTextProvider from './DefaultLicenseTextProvider'\nimport type IAlertAggregator from './types/IAlertAggregator'\nimport type IDefaultLicenseTextProvider from './types/IDefaultLicenseTextProvider'\nimport type IFileSystem from './types/IFileSystem'\nimport type IPackageJson from './types/IPackageJson'\nimport type IPluginOptions from './types/IPluginOptions'\n\n/**\n * Reads license text from license file.\n *\n * If no license file is found, default license texts can automatically\n * be added (either retrieved from spdx github repository or read from\n * a directory).\n */\nexport default class LicenseTextReader {\n  constructor(\n    private alertAggregator: IAlertAggregator,\n    private fileSystem: IFileSystem,\n    private options: Pick<IPluginOptions, 'replenishDefaultLicenseTexts'>,\n    private defaultLicenseReader: IDefaultLicenseTextProvider = new DefaultLicenseTextProvider(),\n  ) {}\n\n  public async readLicenseText(\n    meta: IPackageJson,\n    license: string,\n    moduleDir: string,\n  ): Promise<string | null> {\n    const id = `${meta.name}@${meta.version}`\n\n    if (!license) {\n      return null\n    }\n\n    if (license.indexOf('SEE LICENSE IN ') === 0) {\n      const filename = license.split(' ')[3]\n      try {\n        return this.readFile(moduleDir, filename)\n      }\n      // eslint-disable-next-line unused-imports/no-unused-vars\n      catch (e) {\n        this.alertAggregator.addError(\n          `could not find file specified in package.json license field of ${id}`,\n        )\n      }\n    }\n\n    const pathsInModuleDir = this.fileSystem.listPaths(moduleDir)\n    const licenseFilename = this.getLicenseFilename(pathsInModuleDir)\n\n    if (licenseFilename !== null) {\n      return this.readFile(moduleDir, licenseFilename)\n    }\n\n    if (this.options.replenishDefaultLicenseTexts) {\n      return await this.getDefaultLicenseText(license)\n    }\n\n    return null\n  }\n\n  public getLicenseFilename(paths: string[]): string | null {\n    for (const path of paths) {\n      if (/^licen[cs]e/i.test(path)) {\n        return path\n      }\n    }\n\n    return null\n  }\n\n  public readFile(directory: string, filename: string): string {\n    return this.fileSystem\n      .readFile(join(directory, filename))\n      .replace(/\\r\\n/g, '\\n')\n  }\n\n  public async getDefaultLicenseText(license: string): Promise<string> {\n    return await this.defaultLicenseReader.retrieveLicenseText(license)\n  }\n}\n","import needle from 'needle'\n\nexport async function fetch(url: string): Promise<string | null> {\n  const res = await needle('get', url)\n  return res.statusCode === 200 ? res.body : null\n}\n\nexport const REPO_URL\n  = 'https://raw.githubusercontent.com/spdx/license-list-data'\n\ninterface IDefaultLicenseTextCache {\n  [license: string]: string | null\n}\n\nexport default class DefaultLicenseTextProvider {\n  private cache: IDefaultLicenseTextCache = {}\n\n  constructor(private request: typeof fetch = fetch) {}\n\n  public async retrieveLicenseText(license: string): Promise<string | null> {\n    if (!this.cache[license]) {\n      const res = await this.request(`${REPO_URL}/master/text/${license}.txt`)\n      this.cache[license] = res\n    }\n\n    return this.cache[license] || null\n  }\n}\n","import { join } from 'node:path'\nimport type IFileSystem from './types/IFileSystem'\n\n/**\n * Reads notice text from notice file.\n *\n * If no notice file is found returns null.\n */\nexport default class NoticeTextReader {\n  constructor(private fileSystem: IFileSystem) {}\n\n  public async readNoticeText(moduleDir: string): Promise<string | null> {\n    const noticeFilename = this.fileSystem\n      .listPaths(moduleDir)\n      .find(filename => /^notice/i.test(filename))\n\n    if (!noticeFilename) {\n      return null\n    }\n\n    const noticeFilePath = join(moduleDir, noticeFilename)\n    return this.fileSystem.readFile(noticeFilePath).replace(/\\r\\n/g, '\\n')\n  }\n}\n","import LicenseIdentifier from './LicenseIdentifier'\nimport LicenseTextReader from './LicenseTextReader'\nimport NoticeTextReader from './NoticeTextReader'\nimport type IAlertAggregator from './types/IAlertAggregator'\nimport type IFileSystem from './types/IFileSystem'\nimport type ILicenseIdentifier from './types/ILicenseIdentifier'\nimport type ILicenseMetaAggregator from './types/ILicenseMetaAggregator'\nimport type ILicenseTextReader from './types/ILicenseTextReader'\nimport type INoticeTextReader from './types/INoticeTextReader'\nimport type IPackageJson from './types/IPackageJson'\nimport type IPackageJsonReader from './types/IPackageJsonReader'\nimport type IPackageLicenseMeta from './types/IPackageLicenseMeta'\nimport type IPluginOptions from './types/IPluginOptions'\n\nexport default class LicenseMetaAggregator implements ILicenseMetaAggregator {\n  constructor(\n    fileSystem: IFileSystem,\n    alertAggregator: IAlertAggregator,\n    private options: IPluginOptions,\n    private packageJsonReader: IPackageJsonReader,\n    private licenseIdentifier: ILicenseIdentifier = new LicenseIdentifier(\n      alertAggregator,\n    ),\n    private licenseTextReader: ILicenseTextReader = new LicenseTextReader(\n      alertAggregator,\n      fileSystem,\n      options,\n    ),\n    private noticeTextReader: INoticeTextReader = new NoticeTextReader(\n      fileSystem,\n    ),\n  ) { }\n\n  private getNpmTarballUrl(\n    pkgName: string,\n    pkgVersion: string,\n  ) {\n    const scopelessName = pkgName[0] !== '@' ? pkgName : pkgName.split('/')[1]\n    const plusPos = pkgVersion.indexOf('+')\n    const version = plusPos === -1 ? pkgVersion : pkgVersion.substring(0, plusPos)\n    return `https://registry.npmjs.org/${pkgName}/-/${scopelessName}-${version}.tgz`\n  }\n\n  public async aggregateMeta(\n    moduleDirs: string[],\n  ): Promise<IPackageLicenseMeta[]> {\n    const packageSet = new Set()\n    const result: IPackageLicenseMeta[] = []\n    const sortedModuleDirs = moduleDirs.sort((a, b) =>\n      this.packageJsonReader\n        .readPackageJson(a)\n        .name.localeCompare(this.packageJsonReader.readPackageJson(b).name),\n    )\n\n    for (const moduleDir of sortedModuleDirs) {\n      const meta = this.packageJsonReader.readPackageJson(moduleDir)\n      const packageIdentifier = `${meta.name}@${meta.version}`\n\n      if (packageSet.has(packageIdentifier)) {\n        continue\n      }\n\n      if (this.options.excludedPackageTest(meta.name, meta.version)) {\n        continue\n      }\n\n      packageSet.add(packageIdentifier)\n      const license = this.licenseIdentifier.identifyLicense(meta, this.options)\n      const licenseText = await this.licenseTextReader.readLicenseText(\n        meta,\n        license,\n        moduleDir,\n      )\n      const noticeText = this.options.includeNoticeText ? await this.noticeTextReader.readNoticeText(moduleDir) : undefined\n      result.push({\n        name: meta.name,\n        version: meta.version,\n        author: this.getAuthor(meta),\n        repository: this.getRepository(meta),\n        source: this.getNpmTarballUrl(meta.name, meta.version),\n        license,\n        licenseText,\n        ...(noticeText ? { noticeText } : {}),\n      })\n    }\n\n    return result\n  }\n\n  public getAuthor(meta: Pick<IPackageJson, 'author'>): string {\n    return typeof meta.author === 'object'\n      ? `${meta.author.name}${meta.author.email ? ` <${meta.author.email}>` : ''\n      }${meta.author.url ? ` (${meta.author.url})` : ''}`\n      : meta.author\n  }\n\n  public getRepository(meta: Pick<IPackageJson, 'repository'>): string {\n    if (meta.repository && meta.repository.url) {\n      return meta.repository.url\n    }\n    else if (typeof meta.repository === 'string') {\n      return meta.repository\n    }\n\n    return null\n  }\n}\n","import { resolve, sep } from 'node:path'\nimport type IFileSystem from './types/IFileSystem'\nimport type IModuleDirectoryLocator from './types/IModuleDirectoryLocator'\nimport type IPackageJsonReader from './types/IPackageJsonReader'\n\n/**\n * Locates module directories for given filenames by searching\n * the directory tree for package.json files.\n */\n\nexport default class ModuleDirectoryLocator implements IModuleDirectoryLocator {\n  constructor(\n    private fileSystem: IFileSystem,\n    private buildRoot: string,\n    private packageJsonReader: IPackageJsonReader,\n  ) {}\n\n  public getModuleDir(filename: string): string | null {\n    const moduleDir = filename.substring(0, filename.lastIndexOf(sep))\n    return this.checkModuleDir(moduleDir)\n  }\n\n  private checkModuleDir(moduleDir: string): string | null {\n    let dirWithVersion: string | null = null\n    let dirWithLicense: string | null = null\n    let prevModuleDir: string | null = null\n\n    do {\n      if (this.fileSystem.pathExists(`${moduleDir}${sep}package.json`)) {\n        const packageMeta = this.packageJsonReader.readPackageJson(moduleDir)\n\n        if (\n          packageMeta.name !== undefined\n          && packageMeta.version !== undefined\n        ) {\n          dirWithVersion = moduleDir\n\n          if (\n            packageMeta.license !== undefined\n            || packageMeta.licenses !== undefined\n          ) {\n            dirWithLicense = moduleDir\n          }\n        }\n      }\n\n      prevModuleDir = moduleDir\n      moduleDir = resolve(`${moduleDir}${sep}..${sep}`)\n    } while (\n      !dirWithLicense\n      && moduleDir !== prevModuleDir\n      && moduleDir !== this.buildRoot\n    )\n\n    return dirWithLicense || dirWithVersion\n  }\n}\n","import validate from 'spdx-expression-validate'\nimport defaultOptions from './defaultOptions'\nimport type IAlertAggregator from './types/IAlertAggregator'\nimport type IPluginOptions from './types/IPluginOptions'\n\nexport default class OptionsProvider {\n  constructor(private readonly alertAggregator: IAlertAggregator) {}\n\n  public getOptions(inputOptions: Partial<IPluginOptions>): IPluginOptions {\n    this.validateOptions(inputOptions)\n    const options = { ...defaultOptions, ...inputOptions }\n    return options\n  }\n\n  public validateOptions(inputOptions: Partial<IPluginOptions>) {\n    if (inputOptions.additionalFiles) {\n      for (const fileName of Object.keys(inputOptions.additionalFiles)) {\n        if (typeof inputOptions.additionalFiles[fileName] !== 'function') {\n          this.alertAggregator.addError(\n            `Invalid additionalFiles option: Value for key \"${fileName}\" is not a function!`,\n          )\n        }\n      }\n    }\n\n    if (inputOptions.licenseOverrides) {\n      for (const packageVersion of Object.keys(inputOptions.licenseOverrides)) {\n        if (!validate(inputOptions.licenseOverrides[packageVersion])) {\n          this.alertAggregator.addError(\n            `Invalid licenseOverrides option: \"${inputOptions.licenseOverrides[packageVersion]}\" is not a valid SPDX expression!`,\n          )\n        }\n      }\n    }\n\n    if (\n      inputOptions.replenishDefaultLicenseTexts\n      && typeof inputOptions.replenishDefaultLicenseTexts !== 'boolean'\n    ) {\n      this.alertAggregator.addError(\n        `Invalid replenishDefaultLicenseTexts option: Not a boolean!`,\n      )\n    }\n\n    if (\n      inputOptions.includePackages\n      && typeof inputOptions.includePackages !== 'function'\n    ) {\n      this.alertAggregator.addError(\n        `Invalid includePackages option: Not a function!`,\n      )\n    }\n  }\n}\n","import type IPluginOptions from './types/IPluginOptions'\n\nconst defaultOptions: IPluginOptions = {\n  additionalFiles: {},\n  licenseOverrides: {},\n  outputFilename: 'oss-licenses.json',\n  replenishDefaultLicenseTexts: false,\n  includeNoticeText: false,\n  unacceptableLicenseTest: () => false,\n  excludedPackageTest: () => false,\n  includePackages: () => [],\n}\n\nexport default defaultOptions\n","import { join } from 'node:path'\nimport type IFileSystem from './types/IFileSystem'\nimport type IPackageJson from './types/IPackageJson'\n\ninterface IPackageJsonCache {\n  [moduleDir: string]: IPackageJson\n}\n\nexport default class PackageJsonReader {\n  private cache: IPackageJsonCache = {}\n\n  constructor(private fileSystem: IFileSystem) {}\n\n  public readPackageJson(moduleDir: string): IPackageJson {\n    if (!this.cache[moduleDir]) {\n      const path = join(moduleDir, 'package.json')\n      const meta = JSON.parse(this.fileSystem.readFile(path))\n      this.cache[moduleDir] = meta\n    }\n\n    return this.cache[moduleDir]\n  }\n}\n","import webpack from 'webpack'\nimport type IAlertAggregator from './types/IAlertAggregator'\n\nconst WebpackError = webpack.WebpackError\n\nexport default class WebpackAlertAggregator implements IAlertAggregator {\n  private errors: string[] = []\n  private warnings: string[] = []\n\n  constructor(private readonly compilation: webpack.Compilation) {}\n\n  public addError(message: string) {\n    this.errors.push(message)\n  }\n\n  public addWarning(message: string) {\n    this.warnings.push(message)\n  }\n\n  public flushAlerts(prefix: string): void {\n    this.compilation.errors.push(\n      ...this.errors.map(e => new WebpackError(`${prefix}: ${e}`)),\n    )\n    this.errors = []\n    this.compilation.warnings.push(\n      ...this.warnings.map(w => new WebpackError(`${prefix}: ${w}`)),\n    )\n    this.warnings = []\n  }\n}\n","import type { Compilation } from 'webpack'\nimport webpack from 'webpack'\nimport type IAssetManager from './types/IAssetManager'\n\nconst sources = webpack.sources\n\nexport default class WebpackAssetManager implements IAssetManager {\n  constructor(private compilation: Compilation) {}\n\n  public addFile(filename: string, contents: string): void {\n    this.compilation.assets[filename] = new sources.RawSource(contents)\n  }\n}\n","import type * as webpack from 'webpack'\nimport type IWebpackChunkModule from './types/IWebpackChunkModule'\n\nexport type Compilation = Partial<\n  webpack.Compilation & {\n    chunkGraph: {\n      getChunkModulesIterable: (chunk: Chunk) => IWebpackChunkModule[]\n      getChunkEntryModulesIterable: (chunk: Chunk) => IWebpackChunkModule[]\n    }\n  }\n>\n\ntype Chunk = Partial<\n  Pick<\n    webpack.Chunk & {\n      forEachModule?: (callback: (module: IWebpackChunkModule) => void) => void\n      modules?: IWebpackChunkModule[]\n    },\n    'entryModule' | 'forEachModule' | 'modules' | 'modulesIterable'\n  >\n>\n\nexport default class WebpackChunkModuleIterator {\n  public iterateModules(\n    compilation: Compilation,\n    chunk: Chunk,\n    callback: (module: IWebpackChunkModule) => void,\n  ): void {\n    if (typeof compilation.chunkGraph !== 'undefined') {\n      for (const module of compilation.chunkGraph.getChunkModulesIterable(\n        chunk,\n      )) {\n        callback(module)\n      }\n    }\n    else if (typeof chunk.modulesIterable !== 'undefined') {\n      for (const module of chunk.modulesIterable) {\n        // @ts-expect-error module not assignable to IWebpackChunkModule\n        callback(module)\n      }\n    }\n    else if (typeof chunk.forEachModule === 'function') {\n      chunk.forEachModule(callback)\n    }\n    else if (Array.isArray(chunk.modules)) {\n      chunk.modules.forEach(module => callback(module))\n    }\n\n    if (typeof compilation.chunkGraph !== 'undefined') {\n      for (const module of compilation.chunkGraph.getChunkEntryModulesIterable(\n        chunk,\n      )) {\n        callback(module)\n      }\n    }\n    else if (chunk.entryModule) {\n      // @ts-expect-error chunk.entryModule not assignable to IWebpackChunkModule\n      callback(chunk.entryModule)\n    }\n  }\n}\n","import type IWebpackChunkModule from './types/IWebpackChunkModule'\n\nexport default class WebpackModuleFileIterator {\n  public iterateFiles(\n    {\n      resource,\n      rootModule,\n      fileDependencies,\n      dependencies,\n    }: IWebpackChunkModule,\n    callback: (filename: string) => void,\n  ): void {\n    if (resource) {\n      callback(resource)\n    }\n    else if (rootModule?.resource) {\n      callback(rootModule.resource)\n    }\n\n    if (fileDependencies) {\n      fileDependencies.forEach(dep => callback(dep))\n    }\n\n    if (dependencies) {\n      dependencies.forEach(({ originModule, _parentModule }) => {\n        if (originModule?.resource) {\n          callback(originModule.resource)\n        }\n        if (_parentModule?.resource) {\n          callback(_parentModule.resource)\n        }\n      })\n    }\n  }\n}\n","import type * as webpack from 'webpack'\nimport type { Compilation } from './WebpackChunkModuleIterator'\nimport WebpackChunkModuleIterator from './WebpackChunkModuleIterator'\nimport WebpackModuleFileIterator from './WebpackModuleFileIterator'\n\nexport default class WebpackChunkIterator {\n  constructor(\n    private moduleIterator: WebpackChunkModuleIterator = new WebpackChunkModuleIterator(),\n    private fileIterator: WebpackModuleFileIterator = new WebpackModuleFileIterator(),\n  ) {}\n\n  public iterateChunks(\n    compilation: webpack.Compilation,\n    chunks: Set<webpack.Chunk>,\n  ): string[] {\n    const filenames = []\n\n    for (const chunk of chunks) {\n      this.moduleIterator.iterateModules(\n        compilation as Compilation,\n        chunk,\n        (module) => {\n          this.fileIterator.iterateFiles(module, (filename) => {\n            filenames.push(filename)\n          })\n        },\n      )\n    }\n\n    return filenames\n  }\n}\n","import type IFileSystem from './types/IFileSystem'\n\nexport default class WebpackFileSystem implements IFileSystem {\n  constructor(private fs: any) {}\n\n  public pathExists(filename: string): boolean {\n    try {\n      this.fs.statSync(filename)\n      return true\n    }\n    // eslint-disable-next-line unused-imports/no-unused-vars\n    catch (e) {\n      return false\n    }\n  }\n\n  public readFile(filename: string): string {\n    return this.fs.readFileSync(filename).toString('utf8')\n  }\n\n  public listPaths(dir: string): string[] {\n    return this.fs.readdirSync(dir)\n  }\n}\n"]}