{"version":3,"sources":["../src/WebpackLicensePlugin.ts","../src/LicenseFileWriter.ts","../src/LicenseIdentifier.ts","../src/LicenseTextReader.ts","../src/DefaultLicenseTextProvider.ts","../src/NoticeTextReader.ts","../src/LicenseMetaAggregator.ts","../src/ModuleDirectoryLocator.ts","../src/OptionsProvider.ts","../src/defaultOptions.ts","../src/PackageJsonReader.ts","../src/WebpackAlertAggregator.ts","../src/WebpackAssetManager.ts","../src/WebpackChunkModuleIterator.ts","../src/WebpackModuleFileIterator.ts","../src/WebpackChunkIterator.ts","../src/WebpackFileSystem.ts","../src/index.ts"],"sourcesContent":["import type { Chunk, Compilation, Compiler } from 'webpack'\nimport webpack from 'webpack'\nimport LicenseFileWriter from './LicenseFileWriter'\nimport LicenseMetaAggregator from './LicenseMetaAggregator'\nimport ModuleDirectoryLocator from './ModuleDirectoryLocator'\nimport OptionsProvider from './OptionsProvider'\nimport PackageJsonReader from './PackageJsonReader'\nimport WebpackAlertAggregator from './WebpackAlertAggregator'\nimport WebpackAssetManager from './WebpackAssetManager'\nimport WebpackChunkIterator from './WebpackChunkIterator'\nimport WebpackFileSystem from './WebpackFileSystem'\nimport type IPluginOptions from './types/IPluginOptions'\nimport type IWebpackPlugin from './types/IWebpackPlugin'\n\nconst WebpackError = webpack.WebpackError\nconst pluginName = 'WebpackLicensePlugin'\n\ninterface ObservedCompiler {\n  name: string\n  isChild: boolean\n}\n\nexport default class WebpackLicensePlugin implements IWebpackPlugin {\n  private readonly filenames = new Set<string>()\n  private createdFiles = false\n  private observedCompilers: ObservedCompiler[] = []\n\n  constructor(private pluginOptions: Partial<IPluginOptions> = {}) {}\n\n  public apply(compiler: Compiler) {\n    if (typeof compiler.hooks !== 'undefined') {\n      compiler.hooks.compilation.tap(\n        'webpack-license-plugin',\n        this.handleCompilation.bind(this, compiler),\n      )\n      compiler.hooks.watchRun.tapAsync(\n        'webpack-license-plugin',\n        this.handleWatchRun.bind(this),\n      )\n    }\n    // @ts-expect-error plugin doesn't exist on compiler\n    else if (typeof compiler.plugin !== 'undefined') {\n      // @ts-expect-error plugin doesn't exist on compiler\n      compiler.plugin(\n        'compilation',\n        this.handleCompilation.bind(this, compiler),\n      )\n      // @ts-expect-error plugin doesn't exist on compiler\n      compiler.plugin('watchRun', this.handleWatchRun.bind(this))\n    }\n  }\n\n  public async handleWatchRun(_: unknown, callback: () => void) {\n    this.createdFiles = false\n    this.observedCompilers = []\n    callback()\n  }\n\n  public handleCompilation(compiler: Compiler, compilation: Compilation) {\n    if (typeof compilation.hooks !== 'undefined') {\n      if (typeof compilation.hooks.processAssets !== 'undefined') {\n        const boundHandleChunkAssetOptimization\n          = this.handleChunkAssetOptimization.bind(\n            this,\n            compiler,\n            compilation,\n            compilation.chunks,\n          )\n\n        compilation.hooks.processAssets.tapAsync(\n          {\n            name: 'webpack-license-plugin',\n            stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ANALYSE,\n          },\n          (assets, callback) => boundHandleChunkAssetOptimization(callback),\n        )\n      }\n      else {\n        compilation.hooks.optimizeChunkAssets.tapAsync(\n          'webpack-license-plugin',\n          this.handleChunkAssetOptimization.bind(this, compiler, compilation),\n        )\n      }\n    }\n    // @ts-expect-error plugin doesn't exist on compilation\n    else if (typeof compilation.plugin !== 'undefined') {\n      // @ts-expect-error plugin doesn't exist on compilation\n      compilation.plugin(\n        'optimize-chunk-assets',\n        this.handleChunkAssetOptimization.bind(this, compiler, compilation),\n      )\n    }\n  }\n\n  public async handleChunkAssetOptimization(\n    compiler: Compiler,\n    compilation: Compilation,\n    chunks: Set<Chunk>,\n    callback: () => void,\n  ) {\n    this.observedCompilers.push({\n      name: compilation.compiler.name,\n      isChild: compilation.compiler.isChild(),\n    })\n\n    if (this.createdFiles) {\n      const observedCompilersMessage = this.observedCompilers\n        .map(({ name, isChild }) => `compiler: ${name}, isChild: ${isChild}`)\n        .join('\\n')\n      const errorMessage = new WebpackError(\n        `${pluginName}: Found licenses after license files were already created.\\nIf you see this message, you ran into an edge case we thought would not happen. Please open an isssue at https://github.com/codepunkt/webpack-license-plugin/issues with details of your webpack configuration so we can invastigate it further.\\n${observedCompilersMessage}`,\n      )\n      compilation.errors.push(errorMessage)\n      callback()\n      return\n    }\n\n    if (!compilation.compiler.isChild()) {\n      this.createdFiles = true\n    }\n\n    const alertAggregator = new WebpackAlertAggregator(compilation)\n    const optionsProvider = new OptionsProvider(alertAggregator)\n\n    const options = optionsProvider.getOptions(this.pluginOptions)\n    alertAggregator.flushAlerts(pluginName)\n\n    const chunkIterator = new WebpackChunkIterator()\n    for (const filename of chunkIterator.iterateChunks(compilation, chunks)) {\n      this.filenames.add(filename)\n    }\n\n    if (compilation.compiler.isChild()) {\n      callback()\n      return\n    }\n\n    const fileSystem = new WebpackFileSystem(compiler.inputFileSystem)\n    const packageJsonReader = new PackageJsonReader(fileSystem)\n    const licenseFileWriter = new LicenseFileWriter(\n      new WebpackAssetManager(compilation),\n      new ModuleDirectoryLocator(\n        fileSystem,\n        compiler.options.context,\n        packageJsonReader,\n      ),\n      new LicenseMetaAggregator(\n        fileSystem,\n        alertAggregator,\n        options,\n        packageJsonReader,\n      ),\n    )\n\n    await licenseFileWriter.writeLicenseFiles([...this.filenames], options)\n    alertAggregator.flushAlerts(pluginName)\n\n    callback()\n  }\n}\n","import lodash from 'lodash'\nimport type IAssetManager from './types/IAssetManager'\nimport type ILicenseMetaAggregator from './types/ILicenseMetaAggregator'\nimport type IModuleDirectoryLocator from './types/IModuleDirectoryLocator'\nimport type IPluginOptions from './types/IPluginOptions'\n\nconst { compact, uniq } = lodash\n\nexport default class LicenseFileWriter {\n  constructor(\n    private assetManager: IAssetManager,\n    private moduleDirectoryLocator: IModuleDirectoryLocator,\n    private licenseMetaAggregator: ILicenseMetaAggregator,\n  ) {}\n\n  public async writeLicenseFiles(\n    filenames: string[],\n    options: IPluginOptions,\n  ): Promise<void> {\n    const moduleDirs = this.getModuleDirs(filenames)\n    const includePackages = await options.includePackages()\n    const licenseMeta = await this.licenseMetaAggregator.aggregateMeta([\n      ...new Set([...moduleDirs, ...includePackages]),\n    ])\n\n    const fileContents = JSON.stringify(licenseMeta, null, 2)\n    this.assetManager.addFile(options.outputFilename, fileContents)\n\n    for (const filename of Object.keys(options.additionalFiles)) {\n      const result = await options.additionalFiles[filename](licenseMeta)\n      this.assetManager.addFile(filename, result)\n    }\n  }\n\n  public getModuleDirs(filenames: string[]): string[] {\n    return uniq(\n      compact(\n        filenames.map((filename) => {\n          return this.moduleDirectoryLocator.getModuleDir(filename)\n        }),\n      ),\n    )\n  }\n}\n","import validate from 'spdx-expression-validate'\nimport type IAlertAggregator from './types/IAlertAggregator'\nimport type IPackageJson from './types/IPackageJson'\nimport type IPluginOptions from './types/IPluginOptions'\n\n/**\n * Identifies license type based on package.json and selects\n * preferred license type if multiple are found\n */\nexport default class LicenseIdentifier {\n  constructor(\n    private alertAggregator: IAlertAggregator,\n    private readonly preferredLicenses: string[] = [],\n  ) {}\n\n  public identifyLicense(\n    meta: IPackageJson,\n    options: Pick<\n      IPluginOptions,\n      'licenseOverrides' | 'unacceptableLicenseTest'\n    >,\n  ): string | null {\n    const id = `${meta.name}@${meta.version}`\n    let license: string\n\n    if (options.licenseOverrides[id]) {\n      license = options.licenseOverrides[id]\n    }\n    else if (typeof meta.license === 'object') {\n      license = meta.license.type\n    }\n    else if (meta.license) {\n      license = meta.license\n    }\n    else if (Array.isArray(meta.licenses) && meta.licenses.length > 0) {\n      // handle deprecated `licenses` field\n      license\n        = this.findPreferredLicense(meta.licenses.map(l => l.type))\n        || meta.licenses[0].type\n    }\n    else if (typeof meta.licenses === 'string') {\n      // handle invalid string values for deprecated `licenses` field\n      // unfortunately, these are rather common\n      license = meta.licenses\n    }\n\n    if (!license) {\n      this.alertAggregator.addError(`Could not find license info for ${id}`)\n    }\n    else if (options.unacceptableLicenseTest(license)) {\n      this.alertAggregator.addError(\n        `Found unacceptable license \"${license}\" for ${id}`,\n      )\n    }\n    else if (!validate(license)) {\n      this.alertAggregator.addError(\n        `License \"${license}\" for ${id} is not a valid SPDX expression!`,\n      )\n    }\n\n    return license || null\n  }\n\n  private findPreferredLicense(licenseTypes: string[]): string | null {\n    for (const preferredLicenseType of this.preferredLicenses) {\n      for (const licenseType of licenseTypes) {\n        if (preferredLicenseType === licenseType) {\n          return preferredLicenseType\n        }\n      }\n    }\n    return null\n  }\n}\n","import { join } from 'node:path'\nimport DefaultLicenseTextProvider from './DefaultLicenseTextProvider'\nimport type IAlertAggregator from './types/IAlertAggregator'\nimport type IDefaultLicenseTextProvider from './types/IDefaultLicenseTextProvider'\nimport type IFileSystem from './types/IFileSystem'\nimport type IPackageJson from './types/IPackageJson'\nimport type IPluginOptions from './types/IPluginOptions'\n\n/**\n * Reads license text from license file.\n *\n * If no license file is found, default license texts can automatically\n * be added (either retrieved from spdx github repository or read from\n * a directory).\n */\nexport default class LicenseTextReader {\n  constructor(\n    private alertAggregator: IAlertAggregator,\n    private fileSystem: IFileSystem,\n    private options: Pick<IPluginOptions, 'replenishDefaultLicenseTexts'>,\n    private defaultLicenseReader: IDefaultLicenseTextProvider = new DefaultLicenseTextProvider(),\n  ) {}\n\n  public async readLicenseText(\n    meta: IPackageJson,\n    license: string,\n    moduleDir: string,\n  ): Promise<string | null> {\n    const id = `${meta.name}@${meta.version}`\n\n    if (!license) {\n      return null\n    }\n\n    if (license.indexOf('SEE LICENSE IN ') === 0) {\n      const filename = license.split(' ')[3]\n      try {\n        return this.readFile(moduleDir, filename)\n      }\n      // eslint-disable-next-line unused-imports/no-unused-vars\n      catch (e) {\n        this.alertAggregator.addError(\n          `could not find file specified in package.json license field of ${id}`,\n        )\n      }\n    }\n\n    const pathsInModuleDir = this.fileSystem.listPaths(moduleDir)\n    const licenseFilename = this.getLicenseFilename(pathsInModuleDir)\n\n    if (licenseFilename !== null) {\n      return this.readFile(moduleDir, licenseFilename)\n    }\n\n    if (this.options.replenishDefaultLicenseTexts) {\n      return await this.getDefaultLicenseText(license)\n    }\n\n    return null\n  }\n\n  public getLicenseFilename(paths: string[]): string | null {\n    for (const path of paths) {\n      if (/^licen[cs]e/i.test(path)) {\n        return path\n      }\n    }\n\n    return null\n  }\n\n  public readFile(directory: string, filename: string): string {\n    return this.fileSystem\n      .readFile(join(directory, filename))\n      .replace(/\\r\\n/g, '\\n')\n  }\n\n  public async getDefaultLicenseText(license: string): Promise<string> {\n    return await this.defaultLicenseReader.retrieveLicenseText(license)\n  }\n}\n","import needle from 'needle'\n\nexport async function fetch(url: string): Promise<string | null> {\n  const res = await needle('get', url)\n  return res.statusCode === 200 ? res.body : null\n}\n\nexport const REPO_URL\n  = 'https://raw.githubusercontent.com/spdx/license-list-data'\n\ninterface IDefaultLicenseTextCache {\n  [license: string]: string | null\n}\n\nexport default class DefaultLicenseTextProvider {\n  private cache: IDefaultLicenseTextCache = {}\n\n  constructor(private request: typeof fetch = fetch) {}\n\n  public async retrieveLicenseText(license: string): Promise<string | null> {\n    if (!this.cache[license]) {\n      const res = await this.request(`${REPO_URL}/master/text/${license}.txt`)\n      this.cache[license] = res\n    }\n\n    return this.cache[license] || null\n  }\n}\n","import { join } from 'node:path'\nimport type IFileSystem from './types/IFileSystem'\n\n/**\n * Reads notice text from notice file.\n *\n * If no notice file is found returns null.\n */\nexport default class NoticeTextReader {\n  constructor(private fileSystem: IFileSystem) {}\n\n  public async readNoticeText(moduleDir: string): Promise<string | null> {\n    const noticeFilename = this.fileSystem\n      .listPaths(moduleDir)\n      .find(filename => /^notice/i.test(filename))\n\n    if (!noticeFilename) {\n      return null\n    }\n\n    const noticeFilePath = join(moduleDir, noticeFilename)\n    return this.fileSystem.readFile(noticeFilePath).replace(/\\r\\n/g, '\\n')\n  }\n}\n","import LicenseIdentifier from './LicenseIdentifier'\nimport LicenseTextReader from './LicenseTextReader'\nimport NoticeTextReader from './NoticeTextReader'\nimport type IAlertAggregator from './types/IAlertAggregator'\nimport type IFileSystem from './types/IFileSystem'\nimport type ILicenseIdentifier from './types/ILicenseIdentifier'\nimport type ILicenseMetaAggregator from './types/ILicenseMetaAggregator'\nimport type ILicenseTextReader from './types/ILicenseTextReader'\nimport type INoticeTextReader from './types/INoticeTextReader'\nimport type IPackageJson from './types/IPackageJson'\nimport type IPackageJsonReader from './types/IPackageJsonReader'\nimport type IPackageLicenseMeta from './types/IPackageLicenseMeta'\nimport type IPluginOptions from './types/IPluginOptions'\n\nexport default class LicenseMetaAggregator implements ILicenseMetaAggregator {\n  constructor(\n    fileSystem: IFileSystem,\n    alertAggregator: IAlertAggregator,\n    private options: IPluginOptions,\n    private packageJsonReader: IPackageJsonReader,\n    private licenseIdentifier: ILicenseIdentifier = new LicenseIdentifier(\n      alertAggregator,\n    ),\n    private licenseTextReader: ILicenseTextReader = new LicenseTextReader(\n      alertAggregator,\n      fileSystem,\n      options,\n    ),\n    private noticeTextReader: INoticeTextReader = new NoticeTextReader(\n      fileSystem,\n    ),\n  ) { }\n\n  private getNpmTarballUrl(\n    pkgName: string,\n    pkgVersion: string,\n  ) {\n    const scopelessName = pkgName[0] !== '@' ? pkgName : pkgName.split('/')[1]\n    const plusPos = pkgVersion.indexOf('+')\n    const version = plusPos === -1 ? pkgVersion : pkgVersion.substring(0, plusPos)\n    return `https://registry.npmjs.org/${pkgName}/-/${scopelessName}-${version}.tgz`\n  }\n\n  public async aggregateMeta(\n    moduleDirs: string[],\n  ): Promise<IPackageLicenseMeta[]> {\n    const packageSet = new Set()\n    const result: IPackageLicenseMeta[] = []\n    const sortedModuleDirs = moduleDirs.sort((a, b) =>\n      this.packageJsonReader\n        .readPackageJson(a)\n        .name.localeCompare(this.packageJsonReader.readPackageJson(b).name),\n    )\n\n    for (const moduleDir of sortedModuleDirs) {\n      const meta = this.packageJsonReader.readPackageJson(moduleDir)\n      const packageIdentifier = `${meta.name}@${meta.version}`\n\n      if (packageSet.has(packageIdentifier)) {\n        continue\n      }\n\n      if (this.options.excludedPackageTest(meta.name, meta.version)) {\n        continue\n      }\n\n      packageSet.add(packageIdentifier)\n      const license = this.licenseIdentifier.identifyLicense(meta, this.options)\n      const licenseText = await this.licenseTextReader.readLicenseText(\n        meta,\n        license,\n        moduleDir,\n      )\n      const noticeText = this.options.includeNoticeText ? await this.noticeTextReader.readNoticeText(moduleDir) : undefined\n      result.push({\n        name: meta.name,\n        version: meta.version,\n        author: this.getAuthor(meta),\n        repository: this.getRepository(meta),\n        source: this.getNpmTarballUrl(meta.name, meta.version),\n        license,\n        licenseText,\n        ...(noticeText ? { noticeText } : {}),\n      })\n    }\n\n    return result\n  }\n\n  public getAuthor(meta: Pick<IPackageJson, 'author'>): string {\n    return typeof meta.author === 'object'\n      ? `${meta.author.name}${meta.author.email ? ` <${meta.author.email}>` : ''\n      }${meta.author.url ? ` (${meta.author.url})` : ''}`\n      : meta.author\n  }\n\n  public getRepository(meta: Pick<IPackageJson, 'repository'>): string {\n    if (meta.repository && meta.repository.url) {\n      return meta.repository.url\n    }\n    else if (typeof meta.repository === 'string') {\n      return meta.repository\n    }\n\n    return null\n  }\n}\n","import { resolve, sep } from 'node:path'\nimport type IFileSystem from './types/IFileSystem'\nimport type IModuleDirectoryLocator from './types/IModuleDirectoryLocator'\nimport type IPackageJsonReader from './types/IPackageJsonReader'\n\n/**\n * Locates module directories for given filenames by searching\n * the directory tree for package.json files.\n */\n\nexport default class ModuleDirectoryLocator implements IModuleDirectoryLocator {\n  constructor(\n    private fileSystem: IFileSystem,\n    private buildRoot: string,\n    private packageJsonReader: IPackageJsonReader,\n  ) {}\n\n  public getModuleDir(filename: string): string | null {\n    const moduleDir = filename.substring(0, filename.lastIndexOf(sep))\n    return this.checkModuleDir(moduleDir)\n  }\n\n  private checkModuleDir(moduleDir: string): string | null {\n    let dirWithVersion: string | null = null\n    let dirWithLicense: string | null = null\n    let prevModuleDir: string | null = null\n\n    do {\n      if (this.fileSystem.pathExists(`${moduleDir}${sep}package.json`)) {\n        const packageMeta = this.packageJsonReader.readPackageJson(moduleDir)\n\n        if (\n          packageMeta.name !== undefined\n          && packageMeta.version !== undefined\n        ) {\n          dirWithVersion = moduleDir\n\n          if (\n            packageMeta.license !== undefined\n            || packageMeta.licenses !== undefined\n          ) {\n            dirWithLicense = moduleDir\n          }\n        }\n      }\n\n      prevModuleDir = moduleDir\n      moduleDir = resolve(`${moduleDir}${sep}..${sep}`)\n    } while (\n      !dirWithLicense\n      && moduleDir !== prevModuleDir\n      && moduleDir !== this.buildRoot\n    )\n\n    return dirWithLicense || dirWithVersion\n  }\n}\n","import validate from 'spdx-expression-validate'\nimport defaultOptions from './defaultOptions'\nimport type IAlertAggregator from './types/IAlertAggregator'\nimport type IPluginOptions from './types/IPluginOptions'\n\nexport default class OptionsProvider {\n  constructor(private readonly alertAggregator: IAlertAggregator) {}\n\n  public getOptions(inputOptions: Partial<IPluginOptions>): IPluginOptions {\n    this.validateOptions(inputOptions)\n    const options = { ...defaultOptions, ...inputOptions }\n    return options\n  }\n\n  public validateOptions(inputOptions: Partial<IPluginOptions>) {\n    if (inputOptions.additionalFiles) {\n      for (const fileName of Object.keys(inputOptions.additionalFiles)) {\n        if (typeof inputOptions.additionalFiles[fileName] !== 'function') {\n          this.alertAggregator.addError(\n            `Invalid additionalFiles option: Value for key \"${fileName}\" is not a function!`,\n          )\n        }\n      }\n    }\n\n    if (inputOptions.licenseOverrides) {\n      for (const packageVersion of Object.keys(inputOptions.licenseOverrides)) {\n        if (!validate(inputOptions.licenseOverrides[packageVersion])) {\n          this.alertAggregator.addError(\n            `Invalid licenseOverrides option: \"${inputOptions.licenseOverrides[packageVersion]}\" is not a valid SPDX expression!`,\n          )\n        }\n      }\n    }\n\n    if (\n      inputOptions.replenishDefaultLicenseTexts\n      && typeof inputOptions.replenishDefaultLicenseTexts !== 'boolean'\n    ) {\n      this.alertAggregator.addError(\n        `Invalid replenishDefaultLicenseTexts option: Not a boolean!`,\n      )\n    }\n\n    if (\n      inputOptions.includePackages\n      && typeof inputOptions.includePackages !== 'function'\n    ) {\n      this.alertAggregator.addError(\n        `Invalid includePackages option: Not a function!`,\n      )\n    }\n  }\n}\n","import type IPluginOptions from './types/IPluginOptions'\n\nconst defaultOptions: IPluginOptions = {\n  additionalFiles: {},\n  licenseOverrides: {},\n  outputFilename: 'oss-licenses.json',\n  replenishDefaultLicenseTexts: false,\n  includeNoticeText: false,\n  unacceptableLicenseTest: () => false,\n  excludedPackageTest: () => false,\n  includePackages: () => [],\n}\n\nexport default defaultOptions\n","import { join } from 'node:path'\nimport type IFileSystem from './types/IFileSystem'\nimport type IPackageJson from './types/IPackageJson'\n\ninterface IPackageJsonCache {\n  [moduleDir: string]: IPackageJson\n}\n\nexport default class PackageJsonReader {\n  private cache: IPackageJsonCache = {}\n\n  constructor(private fileSystem: IFileSystem) {}\n\n  public readPackageJson(moduleDir: string): IPackageJson {\n    if (!this.cache[moduleDir]) {\n      const path = join(moduleDir, 'package.json')\n      const meta = JSON.parse(this.fileSystem.readFile(path))\n      this.cache[moduleDir] = meta\n    }\n\n    return this.cache[moduleDir]\n  }\n}\n","import webpack from 'webpack'\nimport type IAlertAggregator from './types/IAlertAggregator'\n\nconst WebpackError = webpack.WebpackError\n\nexport default class WebpackAlertAggregator implements IAlertAggregator {\n  private errors: string[] = []\n  private warnings: string[] = []\n\n  constructor(private readonly compilation: webpack.Compilation) {}\n\n  public addError(message: string) {\n    this.errors.push(message)\n  }\n\n  public addWarning(message: string) {\n    this.warnings.push(message)\n  }\n\n  public flushAlerts(prefix: string): void {\n    this.compilation.errors.push(\n      ...this.errors.map(e => new WebpackError(`${prefix}: ${e}`)),\n    )\n    this.errors = []\n    this.compilation.warnings.push(\n      ...this.warnings.map(w => new WebpackError(`${prefix}: ${w}`)),\n    )\n    this.warnings = []\n  }\n}\n","import type { Compilation } from 'webpack'\nimport webpack from 'webpack'\nimport type IAssetManager from './types/IAssetManager'\n\nconst sources = webpack.sources\n\nexport default class WebpackAssetManager implements IAssetManager {\n  constructor(private compilation: Compilation) {}\n\n  public addFile(filename: string, contents: string): void {\n    this.compilation.assets[filename] = new sources.RawSource(contents)\n  }\n}\n","import type * as webpack from 'webpack'\nimport type IWebpackChunkModule from './types/IWebpackChunkModule'\n\nexport type Compilation = Partial<\n  webpack.Compilation & {\n    chunkGraph: {\n      getChunkModulesIterable: (chunk: Chunk) => IWebpackChunkModule[]\n      getChunkEntryModulesIterable: (chunk: Chunk) => IWebpackChunkModule[]\n    }\n  }\n>\n\ntype Chunk = Partial<\n  Pick<\n    webpack.Chunk & {\n      forEachModule?: (callback: (module: IWebpackChunkModule) => void) => void\n      modules?: IWebpackChunkModule[]\n    },\n    'entryModule' | 'forEachModule' | 'modules' | 'modulesIterable'\n  >\n>\n\nexport default class WebpackChunkModuleIterator {\n  public iterateModules(\n    compilation: Compilation,\n    chunk: Chunk,\n    callback: (module: IWebpackChunkModule) => void,\n  ): void {\n    if (typeof compilation.chunkGraph !== 'undefined') {\n      for (const module of compilation.chunkGraph.getChunkModulesIterable(\n        chunk,\n      )) {\n        callback(module)\n      }\n    }\n    else if (typeof chunk.modulesIterable !== 'undefined') {\n      for (const module of chunk.modulesIterable) {\n        // @ts-expect-error module not assignable to IWebpackChunkModule\n        callback(module)\n      }\n    }\n    else if (typeof chunk.forEachModule === 'function') {\n      chunk.forEachModule(callback)\n    }\n    else if (Array.isArray(chunk.modules)) {\n      chunk.modules.forEach(module => callback(module))\n    }\n\n    if (typeof compilation.chunkGraph !== 'undefined') {\n      for (const module of compilation.chunkGraph.getChunkEntryModulesIterable(\n        chunk,\n      )) {\n        callback(module)\n      }\n    }\n    else if (chunk.entryModule) {\n      // @ts-expect-error chunk.entryModule not assignable to IWebpackChunkModule\n      callback(chunk.entryModule)\n    }\n  }\n}\n","import type IWebpackChunkModule from './types/IWebpackChunkModule'\n\nexport default class WebpackModuleFileIterator {\n  public iterateFiles(\n    {\n      resource,\n      rootModule,\n      fileDependencies,\n      dependencies,\n    }: IWebpackChunkModule,\n    callback: (filename: string) => void,\n  ): void {\n    if (resource) {\n      callback(resource)\n    }\n    else if (rootModule?.resource) {\n      callback(rootModule.resource)\n    }\n\n    if (fileDependencies) {\n      fileDependencies.forEach(dep => callback(dep))\n    }\n\n    if (dependencies) {\n      dependencies.forEach(({ originModule, _parentModule }) => {\n        if (originModule?.resource) {\n          callback(originModule.resource)\n        }\n        if (_parentModule?.resource) {\n          callback(_parentModule.resource)\n        }\n      })\n    }\n  }\n}\n","import type * as webpack from 'webpack'\nimport type { Compilation } from './WebpackChunkModuleIterator'\nimport WebpackChunkModuleIterator from './WebpackChunkModuleIterator'\nimport WebpackModuleFileIterator from './WebpackModuleFileIterator'\n\nexport default class WebpackChunkIterator {\n  constructor(\n    private moduleIterator: WebpackChunkModuleIterator = new WebpackChunkModuleIterator(),\n    private fileIterator: WebpackModuleFileIterator = new WebpackModuleFileIterator(),\n  ) {}\n\n  public iterateChunks(\n    compilation: webpack.Compilation,\n    chunks: Set<webpack.Chunk>,\n  ): string[] {\n    const filenames = []\n\n    for (const chunk of chunks) {\n      this.moduleIterator.iterateModules(\n        compilation as Compilation,\n        chunk,\n        (module) => {\n          this.fileIterator.iterateFiles(module, (filename) => {\n            filenames.push(filename)\n          })\n        },\n      )\n    }\n\n    return filenames\n  }\n}\n","import type IFileSystem from './types/IFileSystem'\n\nexport default class WebpackFileSystem implements IFileSystem {\n  constructor(private fs: any) {}\n\n  public pathExists(filename: string): boolean {\n    try {\n      this.fs.statSync(filename)\n      return true\n    }\n    // eslint-disable-next-line unused-imports/no-unused-vars\n    catch (e) {\n      return false\n    }\n  }\n\n  public readFile(filename: string): string {\n    return this.fs.readFileSync(filename).toString('utf8')\n  }\n\n  public listPaths(dir: string): string[] {\n    return this.fs.readdirSync(dir)\n  }\n}\n","import WebpackLicensePlugin from './WebpackLicensePlugin'\n\nexport default WebpackLicensePlugin\n"],"mappings":"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","names":["webpack","lodash","compact","uniq","lodash","LicenseFileWriter","constructor","assetManager","moduleDirectoryLocator","licenseMetaAggregator","writeLicenseFiles","filenames","options","moduleDirs","getModuleDirs","includePackages","licenseMeta","aggregateMeta","Set","fileContents","JSON","stringify","addFile","outputFilename","filename","Object","keys","additionalFiles","result","map","getModuleDir","_LicenseFileWriter","validate","LicenseIdentifier","constructor","alertAggregator","preferredLicenses","identifyLicense","meta","options","id","name","version","license","licenseOverrides","type","Array","isArray","licenses","length","findPreferredLicense","map","l","unacceptableLicenseTest","addError","validate","licenseTypes","preferredLicenseType","licenseType","_LicenseIdentifier","join","needle","fetch","url","res","needle","statusCode","body","REPO_URL","DefaultLicenseTextProvider","constructor","request","cache","retrieveLicenseText","license","_DefaultLicenseTextProvider","LicenseTextReader","constructor","alertAggregator","fileSystem","options","defaultLicenseReader","DefaultLicenseTextProvider","readLicenseText","meta","license","moduleDir","id","name","version","indexOf","filename","split","readFile","addError","pathsInModuleDir","listPaths","licenseFilename","getLicenseFilename","replenishDefaultLicenseTexts","getDefaultLicenseText","paths","path","test","directory","join","replace","retrieveLicenseText","_LicenseTextReader","join","NoticeTextReader","constructor","fileSystem","readNoticeText","moduleDir","noticeFilename","listPaths","find","filename","test","noticeFilePath","join","readFile","replace","_NoticeTextReader","LicenseMetaAggregator","constructor","fileSystem","alertAggregator","options","packageJsonReader","licenseIdentifier","LicenseIdentifier","licenseTextReader","LicenseTextReader","noticeTextReader","NoticeTextReader","getNpmTarballUrl","pkgName","pkgVersion","scopelessName","split","plusPos","indexOf","version","substring","aggregateMeta","moduleDirs","packageSet","Set","result","sortedModuleDirs","sort","a","b","readPackageJson","name","localeCompare","moduleDir","meta","packageIdentifier","has","excludedPackageTest","add","license","identifyLicense","licenseText","readLicenseText","noticeText","includeNoticeText","readNoticeText","undefined","push","author","getAuthor","repository","getRepository","source","email","url","_LicenseMetaAggregator","resolve","sep","ModuleDirectoryLocator","constructor","fileSystem","buildRoot","packageJsonReader","getModuleDir","filename","moduleDir","substring","lastIndexOf","sep","checkModuleDir","dirWithVersion","dirWithLicense","prevModuleDir","pathExists","packageMeta","readPackageJson","name","undefined","version","license","licenses","resolve","_ModuleDirectoryLocator","validate","defaultOptions","additionalFiles","licenseOverrides","outputFilename","replenishDefaultLicenseTexts","includeNoticeText","unacceptableLicenseTest","excludedPackageTest","includePackages","defaultOptions_default","OptionsProvider","constructor","alertAggregator","getOptions","inputOptions","validateOptions","defaultOptions","additionalFiles","fileName","Object","keys","addError","licenseOverrides","packageVersion","validate","replenishDefaultLicenseTexts","includePackages","_OptionsProvider","join","PackageJsonReader","constructor","fileSystem","cache","readPackageJson","moduleDir","path","join","meta","JSON","parse","readFile","_PackageJsonReader","webpack","WebpackError","webpack","WebpackAlertAggregator","constructor","compilation","errors","warnings","addError","message","push","addWarning","flushAlerts","prefix","map","e","w","_WebpackAlertAggregator","webpack","sources","webpack","WebpackAssetManager","constructor","compilation","addFile","filename","contents","assets","RawSource","_WebpackAssetManager","WebpackChunkModuleIterator","iterateModules","compilation","chunk","callback","chunkGraph","module","getChunkModulesIterable","modulesIterable","forEachModule","Array","isArray","modules","forEach","getChunkEntryModulesIterable","entryModule","_WebpackChunkModuleIterator","WebpackModuleFileIterator","iterateFiles","resource","rootModule","fileDependencies","dependencies","callback","forEach","dep","originModule","_parentModule","_WebpackModuleFileIterator","WebpackChunkIterator","constructor","moduleIterator","WebpackChunkModuleIterator","fileIterator","WebpackModuleFileIterator","iterateChunks","compilation","chunks","filenames","chunk","iterateModules","module","iterateFiles","filename","push","_WebpackChunkIterator","WebpackFileSystem","constructor","fs","pathExists","filename","statSync","readFile","readFileSync","toString","listPaths","dir","readdirSync","_WebpackFileSystem","WebpackError","webpack","pluginName","WebpackLicensePlugin","constructor","pluginOptions","filenames","createdFiles","observedCompilers","Set","apply","compiler","hooks","compilation","tap","handleCompilation","bind","watchRun","tapAsync","handleWatchRun","plugin","_","callback","processAssets","boundHandleChunkAssetOptimization","handleChunkAssetOptimization","chunks","name","stage","Compilation","PROCESS_ASSETS_STAGE_ANALYSE","assets","optimizeChunkAssets","push","isChild","observedCompilersMessage","map","join","errorMessage","errors","alertAggregator","WebpackAlertAggregator","options","OptionsProvider","getOptions","flushAlerts","chunkIterator","WebpackChunkIterator","filename","iterateChunks","add","fileSystem","WebpackFileSystem","inputFileSystem","packageJsonReader","PackageJsonReader","LicenseFileWriter","WebpackAssetManager","ModuleDirectoryLocator","context","LicenseMetaAggregator","writeLicenseFiles","_WebpackLicensePlugin","src_default","WebpackLicensePlugin"]}